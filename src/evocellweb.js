var WebCell;
if (!WebCell) {
    WebCell = {};
}

(function () {
    "use strict";

	function ECRuleTable=)
	{
	}
    if (typeof WebCell.parse !== 'function') {
        WebCell.parse = function (text, reviver) {
        	}
        }
}());


/*
class CADefinition
{
}

class CANeighbourhood
{
	private var nrStates;
	private var neighbours;

	public CADefinition(_nrStates, _neighbours)
	{
		nrStates = _nrSytates;
		neighbours = _neighbours;
	}
	
	
}

class CAFrame
{
	private var gl;
	private var width, height;
	private var texture;
}

class CARuletable
{
	private var nrStates;
	private var nrNeighbours;
	private var ruleData; 
	
	public CARuletable(_nrStates, _nrNeighbours)
	{
		
	}
	
}

// encapsulates the shader and the setting of the right attributes in the GL state
// for example setting the ruletable to the right texture
// but could implement i.e. excitable media or larger than gol whoich is not lookup based
interface CAWebGLInterface
{
	// in evocell rulkes loads the compiled prog and sets up the truletabel texture as an attribute
	function LoadShader();
}

class CAInstance
{
	private var gl;
	var caInterface; // typeof CAWebGLInterface  
	var frameNr, frameFlip;
	
	private var width;
	private var height;
	var texture1, texture2;
	var fb1, fb2;
	
	public function CAInstance
	
	function Step()
	{
		caInteface.LoadShader();
		// set the correct texture depending on frameFlip		
		// set the 	correct framebuffer (fb1, fb2) depending on frameFlip	
		// execute the shader

		frameFlip = -frameFlip;
	}
	
	function CreateProg()
	{
		prog = caInterface.CreateFragmentShader();
	}
		
}
		
*/ 